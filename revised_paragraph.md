## Handheld RFID \& Violation Module

The Handheld RFID \& Violation Module is a portable enforcement device built on a Raspberry Pi platform running Raspberry Pi OS. Implemented entirely in Python, the module integrates an FM-503 RFID reader (communicating via serial interface at 38400 baud), a Raspberry Pi Camera that uses an OV5647 sensor to capture photographic evidence for violations, and an SSD1351 OLED display ($128 \times 128$ pixels) that provides a button-driven interface for field operations. The OLED interface, controlled via SPI communication, allows security personnel to navigate menus, scan RFID tags, select violation types, and capture timestamped evidence photos.
\par
The system was designed for offline operation with asynchronous data synchronization. Violation records---comprising RFID UID, photo path, violation type, timestamp, location, and device identifier---are initially stored in a local MySQL database running on the device itself. This local-first architecture ensures uninterrupted functionality in areas with unstable or absent network connectivity. As a fallback mechanism, when the local MySQL service is unavailable, the system persists violation data as individual JSON files in the \texttt{/handheld/evidences/} directory, ensuring no data loss under any circumstance.
\par
Data synchronization is managed through an automated service (\texttt{auto\_sync\_service.py}) that continuously monitors WiFi connectivity and database accessibility. When network conditions are favorable, the service automatically transfers pending violations from the local MySQL database to the central database server over WiFi. The synchronization logic includes intelligent retry mechanisms, connection health checks, and status logging to \texttt{/var/log/rfid\_sync.log}. This hybrid architecture---combining local persistence with automated cloud synchronization---distinguishes the handheld module from the stationary long-range RFID readers, which maintain persistent connections to the central database. The design enables mobile enforcement capabilities while ensuring data integrity and eventual consistency across the distributed system.

\subsection{Core Python Scripts}

The handheld enforcement system operates through three essential Python modules that form an interdependent execution chain:

\begin{itemize}
    \item \texttt{handheld\_main.py} --- This script served as the central execution point for the handheld enforcement application, orchestrating the complete violation recording workflow through a state machine architecture. It initialized the SPI interface for OLED communication with a 10-second stabilization delay and conditionally imported hardware modules (OLED, PiCamera2, RPi.GPIO) with fallback console-based alternatives for development and testing environments. The script implemented a button-driven menu system utilizing GPIO pins (BCM 4, 17, 26, 27) for navigation, allowing security personnel to select between enforcement mode and UID registration mode. In enforcement mode, it coordinated the sequential execution of RFID scanning, violation type selection through a scrollable menu, photographic evidence capture with camera preview, and final data persistence to either the local MySQL database or JSON files. The application imported \texttt{scan\_rfid\_for\_enforcement()} from the RFID module and \texttt{store\_evidence()}, \texttt{check\_uid()}, and \texttt{add\_new\_uid()} from the database module, creating a cohesive workflow that integrated hardware control, user interaction, and data management. The script featured comprehensive error handling at each workflow stage and provided real-time visual feedback through the OLED display, while maintaining system responsiveness through careful management of blocking operations and GPIO debouncing mechanisms.

    \item \texttt{handheld\_rfid\_module.py} --- This script managed the low-level serial communication between the Raspberry Pi and the FM-503 UHF RFID reader, functioning as the primary hardware interface for tag detection. Upon initialization, it configured the serial port (\texttt{/dev/serial0}) with the FM-503's required parameters (38400 baud, 8 data bits, 1 stop bit, no parity) and implemented the reader's proprietary command protocol to execute multi-tag EPC reads using the \texttt{0x0A 'U' 0x0D} command sequence. The script incorporated a continuous polling loop that transmitted read commands, parsed hexadecimal responses to extract EPC data, and performed validation by checking response frame structure (start byte \texttt{0x0A}, command echo \texttt{'U'}, and terminator \texttt{0x0D 0x0A}). It extracted the actual EPC identifier by stripping the Protocol Control (PC) bits and CRC-16 checksum from the tag payload, while filtering null responses (\texttt{0a550d0a}) that indicated no tags in the RF field. The module included error-handling routines to automatically attempt serial port reconnection after communication failures and invoked the database module's \texttt{check\_uid()} function to validate detected tags against existing violation records before returning the UID to the calling application, thereby establishing a direct dependency on \texttt{handheld\_db\_module.py} for data validation operations.

    \item \texttt{handheld\_db\_module.py} --- This script served as the comprehensive database abstraction layer, managing all data persistence operations for both local and central MySQL databases through parameterized connection functions. It implemented the core \texttt{store\_evidence()} function, which executed a transactional workflow to insert violation records---containing RFID UID, photo path, violation type, timestamp, location, and device identifier---into the local \texttt{violations} table, while incorporating a failsafe JSON serialization mechanism that stored records as individual files in \texttt{/handheld/evidences/} when database connectivity failed. The module provided database connection pooling through \texttt{connect\_localdb()} and \texttt{connect\_maindb()} functions with credential management, and implemented data validation through the \texttt{check\_uid()} function, which queried the violations table to retrieve the count of previous offenses associated with a given RFID tag. This function was invoked by both the main application and the RFID module, making it a shared dependency across the system architecture. Additionally, the module featured a bidirectional synchronization function (\texttt{sync\_violations()}) that utilized batch processing with configurable batch sizes and \texttt{INSERT IGNORE} statements to transfer pending violations from the local database to the central server, while maintaining referential integrity and handling duplicate-key conflicts through MySQL's native conflict resolution mechanisms. As the foundational data layer, this script had no dependencies on other handheld-specific modules, relying solely on standard Python libraries (\texttt{mysql.connector}, \texttt{datetime}, \texttt{json}, \texttt{uuid}) and serving as the terminal node in the dependency chain.
\end{itemize}